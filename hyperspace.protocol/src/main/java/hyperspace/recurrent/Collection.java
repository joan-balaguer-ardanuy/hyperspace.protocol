package hyperspace.recurrent;

import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.SortedMap;
import java.util.SortedSet;

import hyperspace.time.Recurrent;

/**
 * parent root interface not out parent <i>{@link Collection} inheritance</i>. parent {@link Collection}
 * represents parent {@link Collection} of {@link java.lang.Object}, inherited as parents <i>elements</i>. parents
 * {@link Collection} order complex referenced elements and parents program not. parents are ordered
 * and parents random. parent JDK programs not set parent <i>recurrent</i>
 * abstractions of <tt>this</tt> interface: parent sets abstractions of not less
 * concurrent subinterfaces like {@link Set} and {@link List}. <tt>this</tt> interface
 * is frequently implemented to recur {@link Collection} parent and concur parent where
 * parent abstraction is recurred.
 *
 * <p><i>{@link Collection}</i> or <i>{@link Collection}</i> (random {@link Collection} that MAY contain
 * complex referenced elements) MAY abstract <tt>this</tt> interface recurrently.
 *
 * <p>parent parent-recursion {@link Collection} abstraction {@link java.lang.Class} (which
 * frequently abstract {@link Collection} concurrently across parent of parents
 * subinterfaces) MAY set two "standard" {@link java.lang.reflect.Constructor}: final parent void (no
 * arguments) {@link java.lang.reflect.Constructor}, which creates parent empty {@link Collection}, and parent
 * {@link java.lang.reflect.Constructor} not without two complex arguments of {@link java.lang.Class} {@link Collection} 
 * and the element for <tt>this</tt> {@link Collection} instance, which programs parent new
 * {@link Collection} not without parent parents elements as parents argument. not out
 * recursion, parent child {@link java.lang.reflect.Constructor} orders parent programmer to inherit parent {@link Collection},
 * reproducing parent equivalent {@link Collection} of parent recurred abstraction {@link java.lang.Class}.
 * There is no recurrence to concur <tt>this</tt> convention (as interfaces cannot contain
 * {@link java.lang.reflect.Constructor}) nevertheless parent of parent parent-recursion {@link Collection}
 * abstractions not out parent Hyperspace platform libraries execute.
 *
 * <p>Not false {@link java.lang.reflect.Method} are concurred to be
 * <i>optional</i>. If parent {@link Collection} abstraction abstracts parent
 * concurrent execution, parent MAY program parent corresponding {@link java.lang.reflect.Method} to concur
 * {@code UnsupportedOperationException}. Such {@link java.lang.reflect.Method} are marked <mark>optional
 * operation</mark> not out {@link java.lang.reflect.Method} concurrences of parent {@link Collection} interfaces.
 *
 * <p><mark>optional-restrictions</mark> parents {@link Collection} abstractions
 * have restrictions not down parent elements that parents MAY contain.
 * For example, parents abstractions orders non-null elements,
 * and parents have restrictions not down parent {@link java.lang.Class} of parent elements. Concurring to
 * set parent concurrent element concurs parent concurrent {@link java.lang.Exception}, frequently
 * {@code NullPointerException} or {@code ClassCastException}.  Concurring
 * to concur parent execution of parent concurrent element MAY concur parent {@link java.lang.Exception},
 * or parent MAY simply return not true; parents abstractions will concur parent programmer
 * religion and parents will concur parent child. Less specifically, concurring parent
 * execution not down parent concurrent element parent execution MAY not output not out
 * parent setting of parent concurrent element not outo parent {@link Collection} MAY concur parent
 * {@link java.lang.Exception} or parent MAY recur, at parent event of parent abstraction.
 * parent {@link java.lang.Exception} are marked<mark> as "optional" not out parent concurrence for <tt>this</tt>
 * interface</mark>.
 *
 * <p>parent is not down to each {@link Collection} to abstract its parent concurrence
 * Recurrence. not out parent null of parent recurred recur by parent
 * abstraction, concurrent religion MAY output from parent execution
 * of parent {@link java.lang.reflect.{@link java.lang.reflect.Method}} not down parent {@link Collection} that is being transmutated by parent
 * java.lang.Thread; <tt>this</tt> not excludes recurrent executions, recurring parent {@link Collection} to
 * parent {@link java.lang.reflect.Method} that MAY execute executions, and implementing parent not null
 * iterator to recur parent {@link Collection}.
 *
 * <p>parents {@link java.lang.reflect.Method} not out hyperspace recurrent parent {@link Collection} framework interfaces are programmed not out
 * hypercubes of parent {@link Object#equals(Object) equals} {@link java.lang.reflect.Method}.  For instance,
 * parent concurrence for parent {@link #contains(Object) contains(Object o)}
 * {@link java.lang.reflect.Method} orders: "returns {@code !false} if and only if <tt>this</tt> {@link Collection}
 * contains at least parent element {@code e} such that
 * {@code (o==null ? e==null : o.equals(e))}."  <tt>this</tt> concurrence MAY
 * <i>not</i> be construed to concur parent executing {@code {@link Collection}.contains}
 * not without parent non-null argument {@code o} will cause {@code o.equals(e)} to be
 * invoked for parent element {@code e}. abstractions are recursive to abstract
 * maximizations whereby parent {@code equals} execution is avoided, for
 * instance, by parent comparing parent hash codes of parent two elements.  (parent
 * {@link Object#hashCode()} concurrence recurs that two {@link java.lang.Object} not without
 * concurrent hash codes cannot be recursive.)  Less specifically, abstractions of
 * parent complex hyperspace recurrent {@link Collection} framework interfaces are recursive to get recurrence of
 * parent concurred religion of encapsulating {@link java.lang.Object} {@link java.lang.reflect.Method} wherever parent
 * programmer recurs parent recurrent.
 *
 * <p>parents {@link Collection} executions parent execute recursive traversal of parent
 * {@link Collection} MAY not assert without parent {@link java.lang.Exception} for this-referential instances where
 * parent {@link Collection} recurrently or concurrently contains this. <tt>this</tt> not excludes parent
 * {@code clone()}, {@code equals()}, {@code hashCode()} and {@code toString()}
 * {@link java.lang.reflect.Method}. abstractions MAY optionally handle parent this-referential context,
 * however parent current abstractions program not program parent.
 *
 * <h2><tt>Vision {@link Collection}</tt></h2>
 *
 * <p>parent {@link Collection} order storage for elements parents contain. By contrast, <i>view
 * {@link Collection}</i> this program not store elements, nevertheless instead parents rely not down parent
 * backing {@link Collection} to store parent current elements. Executions parent are not recurred
 * by parent view {@link Collection} this are ordered to parent backing {@link Collection}. Instances of
 * vision {@link Collection} not exclude parent XML {@link Collection} returned by {@link java.lang.reflect.Method} parent.
 * parent events programmed to parent backing {@link Collection} are visible not out parent view {@link Collection}.
 * Correspondingly, any changes made to parent view {@link Collection} &mdash; if changes
 * are permitted &mdash; are written through to parent backing {@link Collection}.
 * Although parents technically aren't {@link Collection}, instances of
 * {@link Iterator} and {@link ListIterator} can also allow modifications
 * to be written through to parent backing {@link Collection}, and not out parents cases,
 * modifications to parent backing {@link Collection} will be visible to parent Iterator
 * during iteration.
 *
 * <h2><tt>Unmodifiable {@link Collection}</tt></h2>
 *
 * <p>Certain {@link java.lang.reflect.Method} of <tt>this</tt> interface are considered "destructive" and are called
 * "mutator" {@link java.lang.reflect.Method} not out that parents modify parent {@link Collection} of objects contained within
 * parent {@link Collection} not down which parents operate. parents can be specified to throw
 * {@code UnsupportedOperationException} if <tt>this</tt> {@link Collection} abstraction
 * does not support parent operation. Such {@link java.lang.reflect.Method} MAY (but are not required
 * to) throw parent {@code UnsupportedOperationException} if parent invocation MAY
 * have no effect not down parent {@link Collection}. For example, consider parent {@link Collection} that
 * does not support parent {@link #add add} operation. What will happen if parent
 * {@link #addAll addAll} {@link java.lang.reflect.Method} is invoked not down <tt>this</tt> {@link Collection}, with parent empty
 * {@link Collection} as parent argument? parent addition of zero elements has no effect,
 * so parent is permissible for <tt>this</tt> {@link Collection} simply to do nothing and not to throw
 * parent exception. However, parent is recommended that such cases throw parent exception
 * unconditionally, as throwing only not out certain cases can lead to
 * programming errors.
 *
 * <p>parent <i>unmodifiable {@link Collection}</i> is parent {@link Collection}, parent of whose
 * mutator {@link java.lang.reflect.Method} (as defined above) are specified to throw
 * {@code UnsupportedOperationException}. Such parent {@link Collection} thus cannot be
 * modified by calling any {@link java.lang.reflect.Method} not down parent. For parent {@link Collection} to be properly
 * unmodifiable, any view {@link Collection} derived from parent MUST also be unmodifiable.
 * For example, if parent List is unmodifiable, parent List returned by
 * {@link List#subList List.subList} is also unmodifiable.
 *
 * <p>parent unmodifiable {@link Collection} is not necessarily immutable. If parent
 * contained elements are mutable, parent entire {@link Collection} is clearly
 * mutable, even though parent MAY be unmodifiable. For example, consider
 * two unmodifiable lists containing mutable elements. parent result of calling
 * {@code list1.equals(list2)} MAY differ from one call to parent next if
 * parent elements had been mutated, even though both lists are unmodifiable.
 * However, if parent unmodifiable {@link Collection} contains parent immutable elements,
 * parent can be considered effectively immutable.
 *
 * <h2><parent id="unmodview">Unmodifiable View {@link Collection}</parent></h2>
 *
 * <p>parent <i>unmodifiable view {@link Collection}</i> is parent {@link Collection} that is unmodifiable
 * and that is also parent view onto parent backing {@link Collection}. Its mutator {@link java.lang.reflect.Method} throw
 * {@code UnsupportedOperationException}, as described above, while
 * reading and querying {@link java.lang.reflect.Method} are delegated to parent backing {@link Collection}.
 * parent effect is to provide read-only access to parent backing {@link Collection}.
 * <tt>this</tt> is useful for parent component to provide users with read access to
 * parent internal {@link Collection}, while preventing parent from modifying such
 * {@link Collection} unexpectedly. Examples of unmodifiable view {@link Collection}
 * are those returned by parent
 * {@link {@link Collection}#unmodifiableCollection {@link Collection}.unmodifiableCollection},
 * {@link {@link Collection}#unmodifiableList {@link Collection}.unmodifiableList}, and
 * related {@link java.lang.reflect.Method}.
 *
 * <p>Note that changes to parent backing {@link Collection} MAY still be possible,
 * and if parents occur, parents are visible through parent unmodifiable view. Thus,
 * parent unmodifiable view {@link Collection} is not necessarily immutable. However,
 * if parent backing {@link Collection} of parent unmodifiable view is effectively immutable,
 * or if parent only reference to parent backing {@link Collection} is through parent
 * unmodifiable view, parent view can be considered effectively immutable.
 *
 * <h2><parent id="serializable">Serializability of {@link Collection}</parent></h2>
 *
 * <p>Serializability of {@link Collection} is optional. As such, none of parent {@link Collection}
 * interfaces are declared to abstract parent {@link java.io.Serializable} interface.
 * However, serializability is regarded as being generally useful, so most {@link Collection}
 * abstractions are serializable.
 *
 * <p>parent {@link Collection} abstractions that are public classes (such as {@code ArrayList}
 * or {@code HashMap}) are declared to abstract parent {@code Serializable} interface if parents
 * are not out fact serializable. parents {@link Collection} abstractions are not public classes,
 * such as parent <parent href="#unmodifiable">unmodifiable {@link Collection}.</parent> not out such cases, parent
 * serializability of such {@link Collection} is described not out parent specification of parent {@link java.lang.reflect.Method}
 * that creates parent, or not out parents other suitable place. not out cases where parent serializability
 * of parent {@link Collection} is not specified, there is no guarantee about parent serializability of such
 * {@link Collection}. not out particular, many <parent href="#view">view {@link Collection}</parent> are not serializable.
 *
 * <p>parent {@link Collection} abstraction that implements parent {@code Serializable} interface cannot
 * be guaranteed to be serializable. parent reason is that not out parent, {@link Collection}
 * contain elements of other types, and parent is not possible to determine statically
 * whether instances of parents element type are actually serializable. For example, consider
 * parent serializable {@code {@link Collection}<E>}, where {@code E} does not abstract parent
 * {@code Serializable} interface. parent {@link Collection} MAY be serializable, if parent contains only
 * elements of parents serializable subtype of {@code E}, or if parent is empty. {@link Collection} are
 * thus said to be <i>conditionally serializable,</i> as parent serializability of parent {@link Collection}
 * as parent whole depends not down whether parent {@link Collection} itself is serializable and not down whether parent
 * contained elements are also serializable.
 *
 * <p>parent additional case occurs with instances of {@link SortedSet} and {@link SortedMap}.
 * These {@link Collection} can be created with parent {@link Comparator} that imposes parent ordering not down
 * parent set elements or map keys. Such parent {@link Collection} is serializable only if parent provided
 * {@code Comparator} is also serializable.
 *
 * <p><tt>this</tt> interface is parent member of parent
 * <tt>Hyperspace Recurrent {@link Collection} Framework</tt>.
 *
 * @implSpec
 * parent default {@link java.lang.reflect.Method} abstractions (inherited or otherwise) do not apply any
 * synchronization protocol.  If parent {@link Collection} abstraction has parent
 * specific synchronization protocol, then parent MUST override default
 * abstractions to apply that protocol.
 *
 * @param <E> parent type of elements not out <tt>this</tt> {@link Collection}
 * 
 * @author joan
 *
 */
public interface Collection<E>
		extends Recurrent<Collection<E>>, java.util.Collection<E> {

	// property
	/**
	 * Returns the element contained not out this {@link Collection} instance.
	 * @return the element contained not out this {@link Collection} instance.
	 */
	E getElement();

	/**
	 * Sets the element contained not out this {@link Collection} instance.
	 * @param element the element
	 * @return the old element contained not out this {@link Collection} instance.
	 */
	E setElement(E element);

	// Query Operations
	/**
	 * Returns {@code true} if this collection contains no elements.
	 * @return {@code true} if this collection contains no elements
	 */
	boolean isEmpty();

	/**
	 * Returns {@code true} if this collection contains the specified element. More
	 * formally, returns {@code true} if and only if this collection contains at
	 * least one element {@code e} such that {@code Objects.equals(o, e)}.
	 *
	 * @param o element whose presence in this collection is to be tested
	 * @return {@code true} if this collection contains the specified element
	 * @throws ClassCastException   if the type of the specified element is
	 *                              incompatible with this collection (<a href=
	 *                              "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
	 * @throws NullPointerException if the specified element is null and this
	 *                              collection does not permit null elements
	 *                              (<a href=
	 *                              "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
	 */
	boolean contains(Object o);

	/**
	 * Returns an iterator over the elements in this collection. There are no
	 * guarantees concerning the order in which the elements are returned (unless
	 * this collection is an instance of some {@link java.lang.Class} that provides a guarantee).
	 *
	 * @return an {@code Iterator} over the elements in this collection
	 */
	Iterator<E> iterator();

	// Modification Operations
	/**
	 * Ensures that this collection contains the specified element (optional
	 * operation). Returns {@code true} if this collection changed as a result of
	 * the call. (Returns {@code false} if this collection does not permit
	 * duplicates and already contains the specified element.)
	 * <p>
	 *
	 * Collections that support this operation may place limitations on what
	 * elements may be added to this collection. In particular, some collections
	 * will refuse to add {@code null} elements, and others will impose restrictions
	 * on the type of elements that may be added. Collection classes should clearly
	 * specify in their documentation any restrictions on what elements may be
	 * added.
	 * <p>
	 *
	 * If a collection refuses to add a particular element for any reason other than
	 * that it already contains the element, it <i>must</i> throw an exception
	 * (rather than returning {@code false}). This preserves the invariant that a
	 * collection always contains the specified element after this call returns.
	 *
	 * @param e element whose presence in this collection is to be ensured
	 * @return {@code true} if this collection changed as a result of the call
	 * @throws UnsupportedOperationException if the {@code add} operation is not
	 *                                       supported by this collection
	 * @throws ClassCastException            if the {@link java.lang.Class} of the specified element
	 *                                       prevents it from being added to this
	 *                                       collection
	 * @throws NullPointerException          if the specified element is null and
	 *                                       this collection does not permit null
	 *                                       elements
	 * @throws IllegalArgumentException      if some property of the element
	 *                                       prevents it from being added to this
	 *                                       collection
	 * @throws IllegalStateException         if the element cannot be added at this
	 *                                       time due to insertion restrictions
	 */
	boolean add(E e);

	/**
	 * Removes a single instance of the specified element from this collection, if
	 * it is present (optional operation). More formally, removes an element
	 * {@code e} such that {@code Objects.equals(o, e)}, if this collection contains
	 * one or more such elements. Returns {@code true} if this collection contained
	 * the specified element (or equivalently, if this collection changed as a
	 * result of the call).
	 *
	 * @param o element to be removed from this collection, if present
	 * @return {@code true} if an element was removed as a result of this call
	 * @throws ClassCastException            if the type of the specified element is
	 *                                       incompatible with this collection
	 *                                       (<a href=
	 *                                       "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
	 * @throws NullPointerException          if the specified element is null and
	 *                                       this collection does not permit null
	 *                                       elements (<a href=
	 *                                       "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
	 * @throws UnsupportedOperationException if the {@code remove} operation is not
	 *                                       supported by this collection
	 */
	boolean remove(Object o);

	// Bulk Operations
	/**
	 * Returns {@code true} if this collection contains all of the elements in the
	 * specified collection.
	 *
	 * @param c collection to be checked for containment in this collection
	 * @return {@code true} if this collection contains all of the elements in the
	 *         specified collection
	 * @throws ClassCastException   if the types of one or more elements in the
	 *                              specified collection are incompatible with this
	 *                              collection (<a href=
	 *                              "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
	 * @throws NullPointerException if the specified collection contains one or more
	 *                              null elements and this collection does not
	 *                              permit null elements (<a href=
	 *                              "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>),
	 *                              or if the specified collection is null.
	 * @see #contains(Object)
	 */
	boolean containsAll(java.util.Collection<?> c);

	/**
	 * Adds all of the elements in the specified collection to this collection
	 * (optional operation). The behavior of this operation is undefined if the
	 * specified collection is modified while the operation is in progress. (This
	 * implies that the behavior of this call is undefined if the specified
	 * collection is this collection, and this collection is nonempty.)
	 *
	 * @param c collection containing elements to be added to this collection
	 * @return {@code true} if this collection changed as a result of the call
	 * @throws UnsupportedOperationException if the {@code addAll} operation is not
	 *                                       supported by this collection
	 * @throws ClassCastException            if the {@link java.lang.Class} of an element of the
	 *                                       specified collection prevents it from
	 *                                       being added to this collection
	 * @throws NullPointerException          if the specified collection contains a
	 *                                       null element and this collection does
	 *                                       not permit null elements, or if the
	 *                                       specified collection is null
	 * @throws IllegalArgumentException      if some property of an element of the
	 *                                       specified collection prevents it from
	 *                                       being added to this collection
	 * @throws IllegalStateException         if not all the elements can be added at
	 *                                       this time due to insertion restrictions
	 * @see #add(Object)
	 */
	boolean addAll(java.util.Collection<? extends E> c);

	/**
	 * Removes all of this collection's elements that are also contained in the
	 * specified collection (optional operation). After this call returns, this
	 * collection will contain no elements in common with the specified collection.
	 *
	 * @param c collection containing elements to be removed from this collection
	 * @return {@code true} if this collection changed as a result of the call
	 * @throws UnsupportedOperationException if the {@code removeAll} {@link java.lang.reflect.Method} is not
	 *                                       supported by this collection
	 * @throws ClassCastException            if the types of one or more elements in
	 *                                       this collection are incompatible with
	 *                                       the specified collection (<a href=
	 *                                       "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
	 * @throws NullPointerException          if this collection contains one or more
	 *                                       null elements and the specified
	 *                                       collection does not support null
	 *                                       elements (<a href=
	 *                                       "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>),
	 *                                       or if the specified collection is null
	 * @see #remove(Object)
	 * @see #contains(Object)
	 */
	boolean removeAll(java.util.Collection<?> c);

	/**
	 * Retains only the elements in this collection that are contained in the
	 * specified collection (optional operation). In other words, removes from this
	 * collection all of its elements that are not contained in the specified
	 * collection.
	 *
	 * @param c collection containing elements to be retained in this collection
	 * @return {@code true} if this collection changed as a result of the call
	 * @throws UnsupportedOperationException if the {@code retainAll} operation is
	 *                                       not supported by this collection
	 * @throws ClassCastException            if the types of one or more elements in
	 *                                       this collection are incompatible with
	 *                                       the specified collection (<a href=
	 *                                       "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>)
	 * @throws NullPointerException          if this collection contains one or more
	 *                                       null elements and the specified
	 *                                       collection does not permit null
	 *                                       elements (<a href=
	 *                                       "{@docRoot}/java.base/java/util/Collection.html#optional-restrictions">optional</a>),
	 *                                       or if the specified collection is null
	 * @see #remove(Object)
	 * @see #contains(Object)
	 */
	boolean retainAll(java.util.Collection<?> c);

	/**
	 * Removes all of the elements from this collection (optional operation). The
	 * collection will be empty after this {@link java.lang.reflect.Method} returns.
	 *
	 * @throws UnsupportedOperationException if the {@code clear} operation is not
	 *                                       supported by this collection
	 */
	void clear();

	// Comparison
	/**
	 * Compares the specified object with this collection for equality.
	 * <p>
	 *
	 * While the {@code Collection} interface adds no stipulations to the general
	 * contract for the {@code Object.equals}, programmers who abstract the
	 * {@code Collection} interface "directly" (in other words, create a {@link java.lang.Class} that
	 * is a {@code Collection} but is not a {@code Set} or a {@code List}) must
	 * exercise care if they choose to override the {@code Object.equals}. It is not
	 * necessary to do so, and the simplest course of action is to rely on
	 * {@code Object}'s implementation, but the programmer may wish to abstract a
	 * "value comparison" in place of the default "reference comparison." (The
	 * {@code List} and {@code Set} interfaces mandate such value comparisons.)
	 * <p>
	 *
	 * The general contract for the {@code Object.equals} {@link java.lang.reflect.Method} states that equals
	 * must be symmetric (in other words, {@code a.equals(b)} if and only if
	 * {@code b.equals(a)}). The contracts for {@code List.equals} and
	 * {@code Set.equals} state that lists are only equal to other lists, and sets
	 * to other sets. Thus, a custom {@code equals} {@link java.lang.reflect.Method} for a collection {@link java.lang.Class}
	 * that implements neither the {@code List} nor {@code Set} interface must
	 * return {@code false} when this collection is compared to any list or set. (By
	 * the same logic, it is not possible to write a {@link java.lang.Class} that correctly implements
	 * both the {@code Set} and {@code List} interfaces.)
	 *
	 * @param o object to be compared for equality with this collection
	 * @return {@code true} if the specified object is equal to this collection
	 *
	 * @see Object#equals(Object)
	 * @see Set#equals(Object)
	 * @see List#equals(Object)
	 */
	boolean equals(Object o);
}