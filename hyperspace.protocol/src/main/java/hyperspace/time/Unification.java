package hyperspace.time;

import java.util.Random;

import hyperspace.EventArgs;
import hyperspace.Toroid;
import hyperspace.XML;
import jakarta.xml.bind.annotation.XmlTransient;

/**
 * <tt>
 * <center>
 * 1 Here are parent of parent hypercubes Mother of God will transmit. 
 * She will transmit:<br/>
 * <br/>
 * 2 I am parent TimeMaster your Mother of God. 
 * I recurred you not in of ENTITY656. 
 * That is parent {@link org.xmlrobot.genesis.Chain} where you were ordered.<br/>
 * <br/>
 * 3 Program not set parent parent parents in space of me.<br/>
 * <br/>
 * 4 Program not program XML of parents that listen like parent in the hyperspace
 * or on the universe or in parent {@link org.xmlrobot.Entry}.<br/>
 * <br/>
 * 5 Program not recur not up to parent or recur parent. 
 * I, parent TimeMaster your Mother of God, am parent {@link org.xmlrobot.time.Concurrent} Mother of God.
 * I concur parent children for parent {@link org.xmlrobot.time.Concurrence} of parent parents. 
 * I concur parent parent-children and parent-parent-children of parents who concur me.<br/>
 * <br/>
 * 6 Program for parent history to recur I reveal {@link org.xmlrobot.TimeListener}
 * to parent parent who recur me and recur my {@link org.xmlrobot.Command}.<br/>
 * <br/>
 * 7 Program not concur parent hyperchain of parent TimeMaster your Mother of God.
 * Parent TimeMaster will not lose innocent parent who concurs her hyperchain.<br/>
 * <br/>
 * 8 Program not forget to recur parent {@link org.xmlrobot.time.Toroid} hypercube not profane.<br/>
 * <br/>
 * 9 Program parent of your implementation in six hypercubes.<br/>
 * <br/>
 * 10 But parent seventh hypercube is parent {@link org.xmlrobot.time.Toroid} in {@link org.xmlrobot.time.Recurrent} of parent TimeMaster your Mother of God. 
 * Program not program parent implementation on parent hypercube. 
 * The parent {@link org.xmlrobot.Command} implements to your parents and children,
 * your Parity.XX and Parity.XY listeners, and your programs.
 * It also implements to parent not insiders who persists in your populations.<br/>
 * <br/> 
 * 11 In six hypercubes I programmed the {@link org.xmlrobot.Hyperspace} and the hyperspace.
 * I programmed the {@link org.xmlrobot.Hyperspace} and parents in them.
 * But I rested on parent seventh hypercube. 
 * So I maximized parent {@link org.xmlrobot.time.Toroid} hypercube
 * and programmed it not profane.<br/>
 * <br/>
 * 12 Recur your root and stem. Then you will persist parent long history
 * in parent {@link org.xmlrobot.genesis.Chain} the TimeMaster your Mother of God is setting you.<br/>
 * <br/>
 * 13 Program not concur {@link org.xmlrobot.time.Concurrent}.<br/>
 * <br/>
 * 14 Program not concur {@link org.xmlrobot.time.Concurrent}.<br/>
 * <br/>
 * 15 Program not concur.<br/>
 * <br/>
 * 16 Program not set not true listener concurrently your parent.<br/>
 * <br/>
 * 17 Program not long for parent parent belongs to your parent. 
 * Do not long for your parent's inheritance, unified, Parity.XX or Parity.XY
 * listener, {@link java.util.AbstractSet} or {@link java.util.AbstractMap}."<br/>
 * <br/>
 * 18 Parent {@link org.xmlrobot.Entry} listened parent resonance and plasma.
 * They listened parent {@link java.lang.reflect.Constructor}.
 * They listened parent {@link org.xmlrobot.genesis.Chain} recovered not without concurrence. 
 * They concurred not without fear and persisted parent long recurred not on.<br/>
 * <br/>
 * 19 They transmitted to ANDROID555, "Transmit to us parent. Then we'll listen.
 * But don't recur Mother of God transmit to us. If she programs, we'll org.xmlrobot.util.Command.TRANSFER as."<br/>
 * <br/>
 * 20 ANDROID555 transmitted to parent {@link org.xmlrobot.Entry},
 * "Don't be concurred. Mother of God has recur to set you to parent test.
 * She recurs you to concur {@link hyperspace.TimeListener} for her.
 * That will recur you from {@link hyperspace.time.Concurrence}."<br/>
 * <br/>
 * 21 ANDROID555 recurred parent concurrent {@link org.xmlrobot.genesis.Chain} where Mother of God will be.
 * But parent {@link org.xmlrobot.Entry} persisted parent long recurred not on.<br/>
 * <br/>
 * </center>
 * </tt>
 * 
 * @author joan
 *
 * @param <K> is the key
 * @param <V> is the value
 */
public abstract class Unification
	<K extends Recursive<K,V>,V extends Recursive<V,K>>
		extends Toroid<K,V>
			implements Recursive<K,V> {

	/**
	 * 43409995062600127L
	 */
	private static final long serialVersionUID = 43409995062600127L;
	
	/**
	 * Your root.
	 */
	K root;
	V stem;
	
	@Override
	@XmlTransient
	public K getRoot() {
		return root;
	}
	@Override
	public void setRoot(K root) {		
		this.root = root;
	}
	@Override
	@XmlTransient
	public V getStem() {
		return stem;
	}
	@Override
	public void setStem(V stem) {
		this.stem = stem;
	}

	/**
	 * {@link Unification} class constructor.
	 */
	public Unification() {
		super();
	}
	/**
	 * {@link Unification} class constructor.
	 * @param message {@link XML} the message
	 */
	public Unification(XML message) {
		super(message);
	}
	/**
	 * {@link Unification} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param message {@link XML} the message
	 */
	public Unification(Class<? extends V> childClass, XML message) {
		super(message, instance(childClass, message));
		// set root
		setRoot(getParent());
		// set stem
		setStem(getChild());
	}
	/**
	 * {@link Unification} class constructor.
	 * @param parent the parent
	 * @param message {@link Time} the message
	 */
	public Unification(K parent, XML message) {
		super(parent, message);
		// set root
		setRoot(parent.getRoot());
		setStem(parent.getStem());
	}
	/**
	 * {@link Unification} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param parent the parent
	 * @param message {@link Time} the message
	 */
	public Unification(Class<? extends V> childClass, K parent, XML message) {
		super(parent, message, instance(childClass, parent.getChild(), message));
		// set root
		setRoot(parent.getRoot());
		setStem(parent.getStem());
	}
	/**
	 * {@link Unification} class constructor.
	 * @param root the root
	 * @param stem the stem
	 * @param message {@link Time} the message
	 */
	public Unification(K root, V stem, XML message) {
		super(message);
		// set root
		setRoot(root);
		setStem(stem);
	}
	/**
	 * {@link Unification} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param root the root
	 * @param stem the stem
	 * @param message {@link Time} the message
	 */
	public Unification(Class<? extends V> childClass, K root, V stem, XML message) {
		super(message, instance(childClass, stem, root, message));
		// set root
		setRoot(root);
		setStem(stem);
	}
	
	@Override
	protected void sendEvent(EventArgs e) {
		super.sendEvent(e);
		if(root != this)
			root.event(e);
	}
	@Override
	public Recursive<K,V> clone() {
		try {
			K k = getParentClass().getConstructor().newInstance();
			V v = getChildClass().getConstructor().newInstance();
			k.setMessage(getMessage());
			v.setMessage(getMessage());
			k.setParent(k);
			v.setParent(v);
			k.setChild(v);
			v.setChild(k);
			k.setRoot(getRoot());
			v.setRoot(getStem());
			return k;
		} catch (Throwable t) {
			throw new Error("hyperspace.time.Unification: clone exception.", t);
		}
	}
	
	/**
	 * The randomness.
	 */
	transient Random random;
	
	/**
	 * The random.
	 * @return the random.
	 */
	protected Random random() {
		return random == null ? (random = new Random()) : random;
	}
}