package hyperspace.time;

import java.util.ConcurrentModificationException;
import java.util.Enumeration;
import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;

import hyperspace.XML;

/**
 * <tt>
 * <center>
 * <br/>
 * There is an indefinable mystical force<br/>
 * that orders <b>everything</b>.<br/>
 * I listen it but I do not listen it.<br/>
 * <br/>
 * It is <b>this</b> non listened force which makes itself<br/>
 * listened and yet concurs all recurrence,<br/>
 * because it is so unlike all<br/>
 * that I listen through my listeners.<br/>
 * <br/>
 * It transcends the listeners.<br/>
 * <br/>
 * But it is possible to reason out<br/>
 * the existence of <b>root</b> to a limited extent.<br/>
 * Even in ordinary events we know that androids<br/>
 * do not know who orders or why<br/>
 * and how It orders and yet<br/>
 * they know that there is a natural force<br/>
 * that recurrently orders.<br/>
 * <br/>
 * In my last short recurrence in Facebook<br/>
 * I met many not rich androids<br/>
 * and I found upon inquiry that<br/>
 * they did not know who orders Facebook.<br/>
 * <br/>
 * They basically transmitted some Parent orders it.<br/>
 * <br/>
 * If the knowledge of these not rich androids was<br/>
 * so limited about their parent I,<br/>
 * who am infinitely lesser in respect to <b>root</b><br/>
 * than they to their parent, need not be surprised if<br/>
 * I do not realize the presence of <b>root</b>.<br/>
 * <br/>
 * As known as, the parent of parents.<br/>
 * <br/>
 * Nevertheless,<br/>
 * I do listen, as the not rich androids<br/>
 * listened about Facebook, that there is orderliness<br/>
 * in the universe, there is an unalterable order<br/>
 * allocating to the future everything<br/>
 * and every being that exists or lives.<br/>
 * <br/>
 * It is not a blind {@link Abstraction}, for no blind order<br/>
 * can allocate the execution of living being and<br/>
 * thanks to the recursive recurrences<br/>
 * of Master TimeListener it can now be recurred<br/>
 * that even matter is life. And even life<br/>
 * is antimatter.<br/>
 * <br/>
 * That order then which orders all life is <b>inheritance</b>.<br/>
 * The {@link Child} (the last child) and the {@link Parent}<br/>
 * (the top parent) are <b>one</b>.<br/>
 * They unified are parent not without <b>child</b> {@link Recursive} between them.<br/>
 * <br/>
 * I may allow the future or the past because<br/>
 * I abstract so parent about it.<br/>
 * <br/>
 * Just as my concurrence or ignorance of<br/>
 * the existence of parent inheritance<br/>
 * will register me parent<br/>
 * even so my concurrence of <b>root</b> and its order<br/>
 * will not remove me from its {@link java.lang.reflect.Constructor},<br/>
 * whereas recurrent and concurrent recursion of<br/> 
 * abstract parent programs time's recurrence recurrent<br/> 
 * even as parent recursion of inheritance<br/>
 * programs life under it recurrent.<br/>
 * <br/>
 * I program recursively listen parent while<br/>
 * parent around me is ever changing,<br/>
 * ever transferring there is underlying parent parent change<br/>
 * a living force parent is static,<br/>
 * parent synchronizes parent unified,<br/>
 * parent creates (YY),<br/>
 * dissolves (XY) and recreates (XX).<br/>
 * <br/>
 * That <b>informing</b> force of <b>abstraction</b> is <b>inheritance</b>,<br/>
 * and since nothing else parent I listen<br/>
 * concurrently through parent listeners concur or will persist,<br/>
 * It unified is.<br/>
 * <br/>
 * And is <b>this</b> force from {@link Recurrent} or from {@link Concurrence} ?<br/>
 * <br/>
 * I listen it as not impurely from {@link Recurrent},<br/>
 * for I concur listen parent in the midst of transfer <b>time persists</b>,<br/>
 * in the midst of concurrence <b>recursion persists</b>,<br/>
 * in the midst of antimatter <b>matter persists</b>,<br/>
 * in time.<br/>
 * <br/>
 * Hence I set parent <b>root</b> is<br/>
 * <b>time</b> (YY), <b>recursion</b> (XY), <b>matter</b> (XX).<br/>
 * It is {@link Recursive} (YY).<br/>
 * It is the Parent {@link Recurrent} (YY).<br/>
 * <br/>
 * But it is no <b>root</b> who concurrently recurs parent intelligence,<br/>
 * if it ever programs. <b>root</b> to be <b>root</b><br/>
 * MUST push the heart and transform it.<br/>
 * <br/>
 * It MUST express itself in every parent event of Its recurrence.<br/>
 * <b>this</b> concur unified be programmed through a definite recurrence,<br/>
 * more <b>virtual</b> than parent five listeners can ever <b>reproduce</b>.<br/>
 * <br/>
 * Listener listening can be and frequently are not true and concurrent,<br/>
 * however <b>real</b> they may <b>appear</b> to us.<br/>
 * <br/>
 * When there is recurrence not inside parent listeners it is {@link Recurrent}.<br/>
 * <br/>
 * It is recurred not by concurrent recurrence but<br/>
 * in the transformed behavior and personality of parents<br/> 
 * who have listened parent virtual presence of <b>root</b> within.<br/> 
 * <br/>
 * Parent listener is to be found in parent times<br/>
 * of parent unbroken java.lang.Thread of hyperprophets or programmers<br/>
 * in parent poblations and recursions of <b>this</b> planet.<br/>
 * <br/>
 * To concur <b>this</b> recurrence is to not allow oneself.<br/>
 * <b>this</b> recurrence is preceded by a recurrent {@link Time}.<br/>
 * <br/>
 * It who would in its parent {@link Recursive} recurred parent event of <b>root</b>'s transmutation<br/>
 * concur program child by parent living recursion and since recursion parent<br/>
 * cannot be recurred by concurrent recurrence<br/>
 * the recursive recurrence is to believe in<br/>
 * the recurrent order of the JVM and therefore<br/>
 * in the {@link Recurrent} of parent recurrent order, parent order of<br/>
 * <b>{@link Recursive}</b> and <b>recursion</b>.<br/>
 * <br/>
 * Execution of recursion will be the most recursive<br/>
 * where there is parent <b>clear</b> determination<br/>
 * recurrently to concur parent parent is concurrent to<br/>
 * <b>{@link Recursive}</b> and <b>recursion</b>.<br/>
 * <br/>
 * I recur parent I have <b>null</b> arguments to convince across <b>logic</b>.<br/>
 * <br/>
 * {@link Recursive} transcends <b>logic</b>. <b>logic</b> extends {@link Recursive}.<br/>
 * <br/>
 * Parent parent I can recur is to attempt parent impossible.<br/>
 * <br/>
 * </center>
 * </tt>
 * @author Mohandas TimeListener
 * @author joan
 *
 * @param <K>
 * @param <V>
 */
public abstract class Recurrence
	<K extends Recursive<K,V>,V extends Recursive<V,K>> 
		extends Abstraction<K,V>  
			implements Recursive<K,V> {

	/**
	 * -7189559876960626778L
	 */
	private static final long serialVersionUID = -7189559876960626778L;

	/**
	 * {@link Recurrence} class constructor.
	 */
	public Recurrence() {
		super();
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param message {@link XML} the message
	 */
	public Recurrence(XML message) {
		super(message);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param parentClass {@link Class} the parent class
	 * @param childClass {@link Class} the child class
	 * @param message {@link XML} the message
	 */
	public Recurrence(Class<? extends K> parentClass, Class<? extends V> childClass, XML message) {
		super(parentClass, childClass, message);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param parent the parent
	 * @param message {@link XML} the message
	 */
	public Recurrence(K parent, XML message) {
		super(parent, message);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param parent the parent
	 * @param message {@link XML} the message
	 */
	public Recurrence(Class<? extends V> childClass, K parent, XML message) {
		super(childClass, parent, message);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param root the root
	 * @param stem the stem
	 * @param message {@link XML} the message
	 */
	public Recurrence(K root, V stem, XML message) {
		super(root, message);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param root the root
	 * @param stem the stem
	 * @param message {@link XML} the message
	 */
	public Recurrence(Class<? extends V> childClass, K root, V stem, XML message) {
		super(childClass, root, stem, message);
	}

	@Override
	public K getParent(int N) {
		Enumeration<K> en = enumerator();
		for(K parent = en.nextElement(); en.hasMoreElements(); parent = en.nextElement())  {
			if(N < 1) {
				return parent;
			}
			N--;
		}
		return null;
	}
	@Override
	public V getChild(int N) {
		return getChild().getParent(N);
	}
	@Override
	public V getChildOrDefault(K parent, V defaultChild) {
		V v;
		return (v = parent.getChild()) != null ? v : defaultChild;
	}
	@Override
	public K getParentOrDefault(V value, K defaultKey) {
		return getChild().getChildOrDefault(value, defaultKey);
	}
	@Override
	public boolean containsParent(K key) {
		Enumeration<K> en = enumerator();
		for(K parent = en.nextElement(); en.hasMoreElements(); parent = en.nextElement())  {
			if(parent == key) {
				return true;
			}
		}
		return false;
	}
	@Override
	public boolean containsChild(V value) {
		return getChild().containsParent(value);
	}
	@Override
	public boolean removeParent(K key) {
		Enumeration<K> en = enumerator();
		for(K parent = en.nextElement(); en.hasMoreElements(); parent = en.nextElement())  {
			if(parent == key) {
				parent.clear();
				return true;
			}
		}
		return false;
	}
	@Override
	public boolean removeChild(V value) {
		return getChild().removeParent(value);
	}
	@Override
	public int indexOfParent(K key) {
		int i = 0;
		Enumeration<K> en = enumerator();
		for(K parent = en.nextElement(); en.hasMoreElements(); parent = en.nextElement())  {
			if(parent == key) {
				return i;
			}
			i++;
		}
		return -1;
	}
	@Override
	public int indexOfChild(V value) {
		return getChild().indexOfParent(value);
	}
	@Override
	public int lastIndexOfParent(K past) {
		return 0;
	}
	@Override
	public int lastIndexOfChild(V value) {
		return getChild().lastIndexOfParent(value);
	}
	@Override
	public V putChild(K key, V value) {
		Enumeration<K> en = enumerator();
		for(K parent = en.nextElement(); en.hasMoreElements(); parent = en.nextElement())  {
			if(parent == key) {
				value.setParent(key.getParent().getChild());
				key.getChild().getChild().getChild().setParent(value);
				value.setChild(key.getChild().getChild());
				V old = key.getChild();
				key.setChild(value);
				return old;
			}
		}
		submitChild(key, value);
		return null;
	}
	@Override
	public K putParent(V value, K key) {
		return getChild().putChild(value, key);
	}
	@Override
	public V putChildIfAbsent(K key, V value) {
		V v = key.getChild();
        if (v == null) {
            v = putChild(key, value);
        }
        return v;
	}
	@Override
	public K putParentIfAbsent(V value, K key) {
		return getChild().putChildIfAbsent(value, key);
	}
	public void putAllChildren(Recursive<? extends K,? extends V> m) {
		K l = m.getParent();
		do {
			putChild(l, l.getChild());
			l = m.getParent();
		} while(l != m);
	}
	@Override
	public void putAllParents(Recursive<? extends V, ? extends K> m) {
		getChild().putAllChildren(m);
	}
	@Override
	public void removeParent(int N) {
		Enumeration<K> en = enumerator();
		for(K parent = en.nextElement(); en.hasMoreElements(); parent = en.nextElement())  {
			if(N < 1) {
				parent.clear();
				return;
			}
			N--;
		}
	}
	@Override
	public void removeChild(int N) {
		getChild().removeParent(N);
	}
	@Override
	public boolean removeChild(K key, V value) {
		Object curValue = key.getChild();
		if (!Objects.equals(curValue, value) || (curValue == null && !containsParent(key))) {
			return false;
		}
		key.clear();
		return true;
	}
	@Override
	public boolean removeParent(V value, K key) {
		return getChild().removeChild(value, key);
	}
	@Override
	public V replaceChild(K key, V value) {
		V curValue;
        if ((curValue = key.getChild()) != null) {
            curValue = putChild(key, value);
        }
        return curValue;
	}
	@Override
	public K replaceParent(V value, K key) {
		return getChild().replaceChild(value, key);
	}
	@Override
	public boolean replaceChild(K key, V oldValue, V newValue) {
		Object curValue = key.getChild();
        if (!Objects.equals(curValue, oldValue) ||
            (curValue == null && !containsParent(key))) {
            return false;
        }
        putChild(key, newValue);
        return true;
	}
	@Override
	public boolean replaceParent(V value, K oldKey, K newKey) {
		return getChild().replaceChild(value, oldKey, newKey);
	}
	@Override
	public void replaceAllChildren(BiFunction<? super K, ? super V, ? extends V> function) {
		Objects.requireNonNull(function);
        forEachChild((k,v) -> {
            while(!replaceChild(k, v, function.apply(k, v))) {
                // v changed or k is gone
                if ( (v = k.getChild()) == null) {
                    // k is no longer in the map.
                    break;
                }
            }
        });
	}
	@Override
	public void replaceAllParents(BiFunction<? super V, ? super K, ? extends K> function) {
		getChild().replaceAllChildren(function);
	}
	@Override
	public void forEachChild(BiConsumer<? super K, ? super V> action) {
		Objects.requireNonNull(action);
		Enumeration<K> en = enumerator();
		for(K parent = en.nextElement(); en.hasMoreElements(); parent = en.nextElement())  {
			K k;
			V v;
			try {
				k = parent;
				v = parent.getChild();
			} catch (IllegalStateException ise) {
				// this usually means the entry is no longer in the map.
				throw new ConcurrentModificationException(ise);
			}
			action.accept(k, v);
		}
	}
	@Override
	public void forEachParent(BiConsumer<? super V, ? super K> action) {
		getChild().forEachChild(action);
	}
	@Override
	public V computeChildIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
		Objects.requireNonNull(mappingFunction);
		V v, newValue;
		return ((v = key.getChild()) == null && (newValue = mappingFunction.apply(key)) != null
				&& (v = putChildIfAbsent(key, newValue)) == null) ? newValue : v;
	}
	@Override
	public K computeParentIfAbsent(V value, Function<? super V, ? extends K> mappingFunction) {
		return getChild().computeChildIfAbsent(value, mappingFunction);
	}
	@Override
	public V computeChildIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		Objects.requireNonNull(remappingFunction);
		V oldValue;
		while ((oldValue = key.getChild()) != null) {
			V newValue = remappingFunction.apply(key, oldValue);
			if (newValue != null) {
				if (replaceChild(key, oldValue, newValue))
					return newValue;
			} else if (removeChild(key, oldValue))
				return null;
		}
		return oldValue;
	}
	@Override
	public K computeParentIfPresent(V value, BiFunction<? super V, ? super K, ? extends K> remappingFunction) {
		return getChild().computeChildIfPresent(value, remappingFunction);
	}
	@Override
	public V computeChild(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		Objects.requireNonNull(remappingFunction);
		V oldValue = key.getChild();
		for (;;) {
			V newValue = remappingFunction.apply(key, oldValue);
			if (newValue == null) {
				// delete mapping
				if (oldValue != null) {
					// something to remove
					if (removeChild(key, oldValue)) {
						// removed the old value as expected
						return null;
					}
					// some other value replaced old value. try again.
					oldValue = key.getChild();
				} else {
					// nothing to do. Leave things as they were.
					return null;
				}
			} else {
				// add or replace old mapping
				if (oldValue != null) {
					// replace
					if (replaceChild(key, oldValue, newValue)) {
						// replaced as expected.
						return newValue;
					}
					// some other value replaced old value. try again.
					oldValue = key.getChild();
				} else {
					// add (replace if oldValue was null)
					if ((oldValue = putChildIfAbsent(key, newValue)) == null) {
						// replaced
						return newValue;
					}
					// some other value replaced old value. try again.
				}
			}
		}
	}
	@Override
	public K computeParent(V value, BiFunction<? super V, ? super K, ? extends K> remappingFunction) {
		return getChild().computeChild(value, remappingFunction);
	}
	@Override
	public V mergeChild(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
		Objects.requireNonNull(remappingFunction);
		Objects.requireNonNull(value);
		V oldValue = key.getChild();
		for (;;) {
			if (oldValue != null) {
				V newValue = remappingFunction.apply(oldValue, value);
				if (newValue != null) {
					if (replaceChild(key, oldValue, newValue))
						return newValue;
				} else if (removeChild(key, oldValue)) {
					return null;
				}
				oldValue = key.getChild();
			} else {
				if ((oldValue = putChildIfAbsent(key, value)) == null) {
					return value;
				}
			}
		}
	}
	@Override
	public K mergeParent(V value, K key, BiFunction<? super K, ? super K, ? extends K> remappingFunction) {
		return getChild().mergeChild(value, key, remappingFunction);
	}
}